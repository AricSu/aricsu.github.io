import{_ as a}from"./chunks/03-DM_Worker_Components.CNbSlk6_.js";import{_ as e,c as i,a5 as r,o as t}from"./chunks/framework.PytyN_aB.js";const b=JSON.parse('{"title":"DM Worker","description":"","frontmatter":{},"headers":[],"relativePath":"zh/tidb/05TiDB-生态工具/5-4DM/04TiDB-DM Worker.md","filePath":"zh/tidb/05TiDB-生态工具/5-4DM/04TiDB-DM Worker.md"}'),n={name:"zh/tidb/05TiDB-生态工具/5-4DM/04TiDB-DM Worker.md"};function l(h,s,p,k,o,d){return t(),i("div",null,s[0]||(s[0]=[r('<h1 id="dm-worker" tabindex="-1">DM Worker <a class="header-anchor" href="#dm-worker" aria-label="Permalink to &quot;DM Worker&quot;">​</a></h1><h2 id="what-s-dm-worker" tabindex="-1">What&#39;s DM Worker <a class="header-anchor" href="#what-s-dm-worker" aria-label="Permalink to &quot;What&#39;s DM Worker&quot;">​</a></h2><p>DM Worker从 <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/worker/server.go#L106-L108" target="_blank" rel="noreferrer">func start</a> 开始，启动一系列组件，包括 <code>startKeepAlive</code>， <code>RelayHandler</code>， <code>SubTasks</code>， <code>Syncer</code>。关于 Relay 配置，有一个<a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/worker/server.go#L160-L164" target="_blank" rel="noreferrer">逻辑</a>来判定是否使用远程MySQL Binlog或本地 Relay 日志。</p><figure><img src="'+a+`" alt="DM_Worker_Components" tabindex="0"><figcaption>DM_Worker_Components</figcaption></figure><h2 id="keepalive" tabindex="-1">KeepAlive <a class="header-anchor" href="#keepalive" aria-label="Permalink to &quot;KeepAlive&quot;">​</a></h2><ol><li><p><strong>功能是什么?</strong> DM Worker 与 Master 保持心跳。如果 Worker 失去了与 Master 的连接，它将停止所有任务并尝试再次连接主服务器。</p></li><li><p><strong>它是如何工作的。</strong> <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/worker/join.go#L103" target="_blank" rel="noreferrer">defaultKeepAliveTTL</a>是1分钟，它定期使用<a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/pkg/ha/keepalive.go#L116" target="_blank" rel="noreferrer">etcd cli.Grant</a>将kv与TTL放在etcd。通过这种方式，DM Master可以将子任务转换到另一个活跃的DM Worker中，如果这个Worker已经绑定了一个特定的MySQL Binlog，那么这个Worker就会出现严重的问题。</p></li></ol><h2 id="relay" tabindex="-1">Relay <a class="header-anchor" href="#relay" aria-label="Permalink to &quot;Relay&quot;">​</a></h2><ol><li><p><strong>如何检测它是否已配置。</strong> 当配置不能从 DM Master 获取，这意味着任务已经删除或尚未配置，启动<a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/worker/server.go#L183-L185" target="_blank" rel="noreferrer">逻辑</a>进入<a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/worker/server.go#L686-L688" target="_blank" rel="noreferrer">func enableHandleSubtasks</a>来证明是否使用 Relay 日志。</p></li><li><p><strong>如何工作，如果它是配置。</strong> 更多 Relay 实现信息在<a href="https://cn.pingcap.com/blog/dm-source-code-reading-6" target="_blank" rel="noreferrer">这篇文章- DM源码阅读系列文章(六)中继日志的实现</a>(顺便说一句:你需要英文版本可能需要自行翻译)。简单地说，Relay log 是一个避免远程 MySQL Binlog 突然消失的桥梁功能，它是通过首先读取每个有用的Binlog，比如插入/更新…使用<a href="https://github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go#L128" target="_blank" rel="noreferrer">GetEvent</a>，然后写入中继日志目录来实现，如下所示。DM Worker 在启用 Relay 时，调用<a href="https://github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go#L244" target="_blank" rel="noreferrer">func parseFile</a>解析中继日志到同步器。<br><strong>a. server-uuid.index</strong> : 一个已经组织了binglog事件的索引，以提供一个结构来索引读取的位置。<br><strong>b. 842965eb-091c-11e9-9e45-9a3bff03fa39</strong> : 由 <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/relay/meta.go#L279" target="_blank" rel="noreferrer">func utils.AddSuffixForUUID</a>以 <code>fmt.Sprintf(&quot;%s%s%06d&quot;, uuid, uuidIndexSeparator, id)</code> 格式生成的目录。<br><strong>c. relay.meta</strong> : 记录当前过程或进度。<br><strong>d. mysql-bin.00000X</strong> : X的最大值是正在写入的最新文件。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deploy_dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/relay_log/</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 7e427cc0-091c-11e9-9e45-72b7c59d52d7.000001</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mysql-bin.000001</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mysql-bin.000002</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mysql-bin.000003</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mysql-bin.000004</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> relay.meta</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 842965eb-091c-11e9-9e45-9a3bff03fa39.000002</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mysql-bin.000001</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   \`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> relay.meta</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  server-uuid.index</span></span></code></pre></div></li></ol><h2 id="subtasks" tabindex="-1">SubTasks <a class="header-anchor" href="#subtasks" aria-label="Permalink to &quot;SubTasks&quot;">​</a></h2><ol><li><p><strong>SubTasks 是什么意思</strong> SubTask表示数据迁移的子任务。也就是说，子任务数等于MySQL Binlog数。都是因为他们的关系是1比1。我们可以在下面看到<a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/worker/subtask.go#L77" target="_blank" rel="noreferrer">它的 struct</a>。我们都知道，一个工人到现在为止只有一个binlog。一个值得注意的特性是PingCAP试图解耦 1-1 的关系，您可以通过跟踪 <a href="https://github.com/pingcap/tiflow/issues/4687" target="_blank" rel="noreferrer">Issue</a> 来流动进度。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SubTask</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cfg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SubTaskConfig</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">......</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">workerName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">validator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">syncer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DataValidator</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>它是如何创建的。</strong> 从任务生成子任务的主要地方是在<a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/master/openapi_controller.go#L386" target="_blank" rel="noreferrer">OpenAPITaskToSubTaskConfigs</a>和<a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/master/server.go#L510" target="_blank" rel="noreferrer">StartTask</a>。值得注意的是，不仅只有两个，还有<a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/master/server.go#L725" target="_blank" rel="noreferrer">UpdateTask</a>。但我们只是关注它的来源。所以，如果你感兴趣，你可以自己探索。</p></li></ol><h2 id="sourceworker" tabindex="-1">SourceWorker <a class="header-anchor" href="#sourceworker" aria-label="Permalink to &quot;SourceWorker&quot;">​</a></h2><ol><li><p><strong>它负责什么?</strong> SourceWorker管理一个源(上游)，主要与子任务和中继相关。它有很多函数，如“updateSourceStatus”，“fetchSubTasksAndAdjust”，“operateRelay”和“PurgeRelay”…，我们可以看到功能是什么。</p></li><li><p><strong>它是如何工作的。</strong> 只关注SourceWorker功能的主要部分(StartSubTask)。如前所述，当一个DM Worker启动时，它通过请求etcd来获得子任务配置和绑定关系。因此，遵循 <code>EnableHandleSubtasks——&gt; w.s tstartsubtask——&gt;st. Run——&gt;initUnits——&gt;createUnits</code>，将清楚地显示一个工作逻辑。并且，在 <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/worker/subtask.go#L52" target="_blank" rel="noreferrer">func createRealUnits</a> 中，有一些步骤来调整 <code>modelall</code> 或 <code>ModeIncrement</code> 。如果有兴趣，请自学。</p></li></ol><h2 id="syncer" tabindex="-1">Syncer <a class="header-anchor" href="#syncer" aria-label="Permalink to &quot;Syncer&quot;">​</a></h2><p>我不得不说 <code>Syncer</code> 是 DM Worker 最重要的组件，甚至是DM。所以，它被分成一个单独的内容来解释它是如何工作的。在 <a href="./05TiDB-DM syncer.html">这里</a>。</p>`,14)]))}const f=e(n,[["render",l]]);export{b as __pageData,f as default};
