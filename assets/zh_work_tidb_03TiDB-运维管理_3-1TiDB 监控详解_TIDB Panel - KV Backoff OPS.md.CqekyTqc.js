import{_ as t,c as i,o,a5 as p}from"./chunks/framework.JWlnoUZ4.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh/work/tidb/03TiDB-运维管理/3-1TiDB 监控详解/TIDB Panel - KV Backoff OPS.md","filePath":"zh/work/tidb/03TiDB-运维管理/3-1TiDB 监控详解/TIDB Panel - KV Backoff OPS.md"}'),r={name:"zh/work/tidb/03TiDB-运维管理/3-1TiDB 监控详解/TIDB Panel - KV Backoff OPS.md"};function n(a,e,l,s,c,g){return o(),i("div",null,e[0]||(e[0]=[p(`<ol><li><p>面板简介</p><p>该面板的统计位于下图的 tikv client 模块，如图所示，主要用于统计集群层面 TiDB-Server 与 TiKV-Server 交互过程中，不同“重试”类型的频次。</p></li></ol><p>图片 在 TiDB 的分布式交互中，&quot;重试&quot; 无法根本上完全避免，与其完全避免，采用一种更为合理的解决方案（例如易于理解和实现的优点）更为常见。实现上借鉴了 OCC （乐观并发控制）算法为冲突增加睡眠时间，通过引入睡眠时间来减少冲突的发生频次，从而降低争用。</p><p>图片 该面板有助于分析在性能问题发生时是否因“重试”导致性能下降，并且结合不同的“重试类型”可以进一步关联上下文分析问题的根源。</p><ol start="2"><li><p>面板位置</p><p>Cluster-TiDB --&gt; KV Errors --&gt; KV Backoff OPS</p></li></ol><p>图片</p><ol start="3"><li><p>面板详情</p><p>重试类型：</p></li></ol><p>tikvRPC</p><p>tiflashRPC</p><p>pdRPC</p><p>tikvLockFast</p><p>txnLock</p><p>regionMiss</p><p>regionScheduling</p><p>serverBusy</p><p>tikvDiskFull</p><p>regionRecoveryInProgress</p><p>staleCommand</p><p>isWitness</p><ol><li><p>tikvRPC, tiflashRPC</p><p>这类重试通常伴随出现在TiDB日志中，需要结合上下文分析。日志中的 &quot;send tiflash request error&quot; 和 &quot;tiflash server timeout&quot; 表示tiflash可能发生了不可用；而 &quot;send tikv request error&quot; 和 &quot;tikv server timeout&quot; 表示tikv可能不可用。</p></li><li><p>pdRPC</p><p>这种重试可能发生在 RegionCache、StoreCache、KvStore 和 Split &amp; ScatterRegion 等调用过程中。通常是在与PD通信时发生错误：</p><p>RegionCache：TiDB-Server 内部维护缓存，用于快速定位和访问 Region。如果 RegionCache 中的缓存信息过时，会通过 PD 获取最新的Region信息。</p></li></ol><p>图片 如果 RegionCache 发现自己缓存的 Region 是过旧的会首先从 PD 获取并更新，因为 PD 维护着全局的 Region 信息。因此，调用如果发生错误会归属到 pdRPC 里面。</p><pre><code>   在 tidb.log 中通常会出现对应关键字的日志。
</code></pre><p>failed to decode region range key, key</p><p>loadRegion from PD failed, key</p><p>region not found for key</p><p>receive Region with no available peer</p><p>failed to decode region range key, regionID</p><p>loadRegion from PD failed, regionID</p><p>region not found for regionID</p><p>receive Region with no available peer</p><p>failed to decode region range key, limit</p><p>scanRegion from PD failed, limit</p><p>PD returned no region, limit</p><p>PD returned regions have gaps, limit</p><p>failed to decode region range key, range num</p><p>batchScanRegion from PD failed, range num</p><p>RegionCache 也会维护 Store(TiKV) 的信息，如果请求 PD 发生失败也会重试，可在 tidb.log 中发现下述关键字 loadStore from PD failed, id。</p><p>KvStore : 每个事务都会过 KvStore，有可能会在这里获取 TSO（每次获取一批 TSO），如果获取失败会在 tidb.log 中出现 “get timestamp failed”，“get minimum timestamp failed”。</p><p>Split &amp;ScatterRegion ：TiDB 有很多 Split Region 的地方，由调度自动触发或手动触发，先 Split 一个 Region 为 2 个，再将 Region 调度到不同 Store 上以解决热点问题。主要请求发给 PD 去调度，因此也归类到 pdRPC 类型上。通常在 tidb.log 中会伴有下述日志关键字，“start scatter region”</p><p>batch split regions complete</p><p>start scatter region</p><p>batch split regions, scatter region complete</p><p>batch split regions, scatter region failed</p><ol start="3"><li><p>tikvLockFast, txnLock</p><p>此类重试主要由锁机制引发，是常见的告警类型，本质上无论 “读写冲突” 或 “写写冲突” 都是由事务完成的不够快造成的，遇到该类问题还是建议更细节分析不够快的“根因”，并针对性的解决。</p><p>tikvLockFast：代表出现了读写冲突, 如下图所示。</p></li></ol><p>图片</p><p>txnLock：代表出现了写写冲突，事务在 Prewrite 阶段的第一步就会检查是否有写写冲突，第二步会检查目标 key 是否已经被另一个事务上锁。当检测到该 key 被 lock 后，会自动进行 backoff 重试并记录为 txnLock。</p><ol start="4"><li><p>regionMiss, regionScheduling</p><p>regionMiss : 此重试由 TiDB-Server 发往 TiKV-Server 过程中, Region Cache 中缓存着错误的 region 信息导致， 因为 Region 已经被调度走了。可能在 splitRegion, deleteRange, 2PC Txn, 清锁, 加锁, 清事物, piplineFlush, prewrite, scanRegion, snapshot 过程中遭遇。</p><p>regionScheduling : 此类重试与 regionMiss 类似，但更多特指此时 Region 正在选举或正在调度，所以 tidb.log 会看到关键字 &quot;read index not ready, ctx&quot;, &quot;region is merging, ctx&quot;, &quot;no leader, ctx&quot;。</p></li><li><p>regionRecoveryInProgress</p></li></ol><p>此类重试，特指集群正在进行 Online recovery ，拒绝写入以避免潜在问题发生的重试。</p><ol start="6"><li><p>顾名思义 serverBusy, tikvDiskFull</p><p>serverBusy : 可以分为 tiflashServerBusy 和 tikvServerBusy，</p></li><li><p>staleCommand</p><p>StaleCommand : 表示请求发送给了旧 Region Leader，且其 Term 已更改，无法知道上一个请求是否已提交，需要重试请求。</p></li><li><p>isWitness</p><p>isWitness : 这是TiKV的一项未正式发布的功能。在云环境下，为了保证99.99%的可用性，使用TiKV的Raft三副本会浪费资源。该功能通过引入见证（Witness）角色来提高资源利用率，重试通常发生在相关功能下。</p></li><li><p>参考文献</p></li></ol><p>Exponential Backoff And Jitter | AWS Architecture Blog : <a href="https://aws.amazon.com/cn/blogs/architecture/exponential-backoff-and-jitter" target="_blank" rel="noreferrer">https://aws.amazon.com/cn/blogs/architecture/exponential-backoff-and-jitter</a></p><p>TiDB 锁冲突问题处理 : <a href="https://docs.pingcap.com/zh/tidb/stable/troubleshoot-lock-conflicts" target="_blank" rel="noreferrer">https://docs.pingcap.com/zh/tidb/stable/troubleshoot-lock-conflicts</a></p><p>Github client-go repo : <a href="https://github.com/tikv/client-go" target="_blank" rel="noreferrer">https://github.com/tikv/client-go</a></p><p>witness feature : <a href="https://github.com/tikv/tikv/issues/12876" target="_blank" rel="noreferrer">https://github.com/tikv/tikv/issues/12876</a></p>`,52)]))}const k=t(r,[["render",n]]);export{f as __pageData,k as default};
