var Regex;(Regex||={}).plugins=(()=>{var U=Object.defineProperty;var G=Object.getOwnPropertyDescriptor;var M=Object.getOwnPropertyNames;var W=Object.prototype.hasOwnProperty;var P=(e,t)=>{for(var n in t)U(e,n,{get:t[n],enumerable:!0})},_=(e,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of M(t))!W.call(e,o)&&o!==n&&U(e,o,{get:()=>t[o],enumerable:!(s=G(t,o))||s.enumerable});return e};var H=e=>_(U({},"__esModule",{value:!0}),e);var q={};P(q,{recursion:()=>z});var a=Object.freeze({DEFAULT:"DEFAULT",CHAR_CLASS:"CHAR_CLASS"});function A(e,t,n,s){let o=new RegExp(String.raw`${t}|(?<$skip>\[\^?|\\?.)`,"gsu"),c=[!1],r=0,u="";for(let i of e.matchAll(o)){let{0:l,groups:{$skip:p}}=i;if(!p&&(!s||s===a.DEFAULT==!r)){n instanceof Function?u+=n(i,{context:r?a.CHAR_CLASS:a.DEFAULT,negated:c[c.length-1]}):u+=n;continue}l[0]==="["?(r++,c.push(l[1]==="^")):l==="]"&&r&&(r--,c.pop()),u+=l}return u}function F(e,t,n,s){A(e,t,n,s)}function B(e,t,n=0,s){if(!new RegExp(t,"su").test(e))return null;let o=new RegExp(`${t}|(?<$skip>\\\\?.)`,"gsu");o.lastIndex=n;let c=0,r;for(;r=o.exec(e);){let{0:u,groups:{$skip:i}}=r;if(!i&&(!s||s===a.DEFAULT==!c))return r;u==="["?c++:u==="]"&&c&&c--,o.lastIndex==r.index&&o.lastIndex++}return null}function $(e,t,n){return!!B(e,t,0,n)}function L(e,t){let n=/\\?./gsu;n.lastIndex=t;let s=e.length,o=0,c=1,r;for(;r=n.exec(e);){let[u]=r;if(u==="[")o++;else if(o)u==="]"&&o--;else if(u==="(")c++;else if(u===")"&&(c--,!c)){s=r.index;break}}return e.slice(t,s)}var f=String.raw,j=f`\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`,x=f`\(\?R=(?<rDepth>[^\)]+)\)|${j}`,C=f`\(\?<(?![=!])(?<captureName>[^>]+)>`,w=new RegExp(f`${C}|${x}|\(\?|\\?.`,"gsu"),k="Cannot use multiple overlapping recursions";function z(e){if(!new RegExp(x,"su").test(e))return e;if($(e,f`\(\?\(DEFINE\)`,a.DEFAULT))throw new Error("DEFINE groups cannot be used with recursion");let t=$(e,f`\\[1-9]`,a.DEFAULT),n=new Map,s=[],o=!1,c=0,r=0,u;for(w.lastIndex=0;u=w.exec(e);){let{0:i,groups:{captureName:l,rDepth:p,gRNameOrNum:h,gRDepth:m}}=u;if(i==="[")c++;else if(c)i==="]"&&c--;else if(p){if(I(p),o)throw new Error(k);if(t)throw new Error("Numbered backrefs cannot be used with global recursion");let g=e.slice(0,u.index),d=e.slice(w.lastIndex);if($(d,x,a.DEFAULT))throw new Error(k);return T(g,d,+p,!1)}else if(h){I(m);let g=!1;for(let E of s)if(E.name===h||E.num===+h){if(g=!0,E.hasRecursedWithin)throw new Error(k);break}if(!g)throw new Error(f`Recursive \g cannot be used outside the referenced group "\g<${h}&R=${m}>"`);let d=n.get(h),R=L(e,d);if(t&&$(R,f`${C}|\((?!\?)`,a.DEFAULT))throw new Error("Numbered backrefs cannot be used with recursion of capturing groups");let D=e.slice(d,u.index),N=R.slice(D.length+i.length),b=T(D,N,+m,!0),O=e.slice(0,d),v=e.slice(d+R.length);e=`${O}${b}${v}`,w.lastIndex+=b.length-i.length-D.length-N.length,s.forEach(E=>E.hasRecursedWithin=!0),o=!0}else if(l)r++,n.set(String(r),w.lastIndex),n.set(l,w.lastIndex),s.push({num:r,name:l});else if(i.startsWith("(")){let g=i==="(";g&&(r++,n.set(String(r),w.lastIndex)),s.push(g?{num:r}:{})}else i===")"&&s.pop()}return e}function I(e){let t=`Max depth must be integer between 2 and 100; used ${e}`;if(!/^[1-9]\d*$/.test(e))throw new Error(t);if(e=+e,e<2||e>100)throw new Error(t)}function T(e,t,n,s){let o=new Set;s&&F(e+t,C,({groups:{captureName:r}})=>{o.add(r)},a.DEFAULT);let c=n-1;return`${e}${S(`(?:${e}`,c,s?o:null)}(?:)${S(`${t})`,c,s?o:null,"backward")}${t}`}function S(e,t,n,s="forward"){let c=u=>s==="backward"?t-u+2-1:u+2,r="";for(let u=0;u<t;u++){let i=c(u);r+=A(e,f`${C}|\\k<(?<backref>[^>]+)>`,({0:l,groups:{captureName:p,backref:h}})=>{if(h&&n&&!n.has(h))return l;let m=`_$${i}`;return p?`(?<${p}${m}>`:f`\k<${h}${m}>`},a.DEFAULT)}return r}return H(q);})();
//# sourceMappingURL=regex-recursion.min.js.map
