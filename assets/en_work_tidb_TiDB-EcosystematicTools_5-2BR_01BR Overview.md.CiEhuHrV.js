import{_ as t,c as a,o as r,a4 as o}from"./chunks/framework.svyMRVY3.js";const h=JSON.parse('{"title":"BR Overview","description":"","frontmatter":{},"headers":[],"relativePath":"en/work/tidb/TiDB-EcosystematicTools/5-2BR/01BR Overview.md","filePath":"en/work/tidb/TiDB-EcosystematicTools/5-2BR/01BR Overview.md"}'),i={name:"en/work/tidb/TiDB-EcosystematicTools/5-2BR/01BR Overview.md"};function s(n,e,l,c,d,p){return r(),a("div",null,e[0]||(e[0]=[o('<h1 id="br-overview" tabindex="-1">BR Overview <a class="header-anchor" href="#br-overview" aria-label="Permalink to &quot;BR Overview&quot;">​</a></h1><h2 id="what-s-br" tabindex="-1">What&#39;s BR <a class="header-anchor" href="#what-s-br" aria-label="Permalink to &quot;What&#39;s BR&quot;">​</a></h2><h2 id="how-does-it-work" tabindex="-1">How does it work <a class="header-anchor" href="#how-does-it-work" aria-label="Permalink to &quot;How does it work&quot;">​</a></h2><ol><li>The part that can be tuned --&gt; <a href="https://github.com/tikv/tikv/blob/b5262299604df88711d9ed4b84d43e9c507749a2/src/config.rs#L2217" target="_blank" rel="noreferrer">https://github.com/tikv/tikv/blob/b5262299604df88711d9ed4b84d43e9c507749a2/src/config.rs#L2217</a> a. num_threads : 在事件驱动 pool 的 worker 数量，也就是备份并发度； b. spawn_backup_worker : 去备份数据； c. save_backup_file_worker ： 调用 external storage 去保存数据 ；</li><li>save_backup_file_worker 是按照 region 去 backup --&gt; <a href="https://github.com/tikv/tikv/blob/b5262299604df88711d9ed4b84d43e9c507749a2/components/backup/src/endpoint.rs#L836" target="_blank" rel="noreferrer">https://github.com/tikv/tikv/blob/b5262299604df88711d9ed4b84d43e9c507749a2/components/backup/src/endpoint.rs#L836</a> a. batch_size 就是一次备份多少个 region；</li><li>brange.backup 用 tokio future 扫 region 并落到磁盘上--&gt; <a href="https://github.com/tikv/tikv/blob/b5262299604df88711d9ed4b84d43e9c507749a2/components/backup/src/endpoint.rs#L891" target="_blank" rel="noreferrer">https://github.com/tikv/tikv/blob/b5262299604df88711d9ed4b84d43e9c507749a2/components/backup/src/endpoint.rs#L891</a> a. 文件名应该遵循的是 format!(&quot;{}<em>{}</em>{}<em>{}</em>{}&quot;,store_id,region.get_id(),region.get_region_epoch().get_version(),k,since_the_epoch.as_millis()) 格式保存 --&gt; <a href="https://github.com/tikv/tikv/blob/b5262299604df88711d9ed4b84d43e9c507749a2/components/backup/src/endpoint.rs#L862" target="_blank" rel="noreferrer">https://github.com/tikv/tikv/blob/b5262299604df88711d9ed4b84d43e9c507749a2/components/backup/src/endpoint.rs#L862</a></li><li>用 rust 写了个 mbr 用于模仿 br 的一些功能 --&gt; <a href="https://github.com/jansu-dev/mbr" target="_blank" rel="noreferrer">https://github.com/jansu-dev/mbr</a> a. 目前可以翻译部分 backupmeta b. 手动指定 backupRange 构造 backupRequest 可让 tikv 备份 sst 文件 c. 但 restore 需要读取 backupmeta，rust 这块缺少可用现成库，如：parser.table_info、parser.schema_info 等信息，暂时还无法实现。（陆续实现中...）</li></ol><h2 id="what-s-the-repo-of-yatp" tabindex="-1">what&#39;s the repo of yatp <a class="header-anchor" href="#what-s-the-repo-of-yatp" aria-label="Permalink to &quot;what&#39;s the repo of yatp&quot;">​</a></h2><ol start="2"><li>How does it work:</li><li>yatp encapsulates the repo of crossbeam-deque which is used to construct scheduler using deque structure and looks simple.</li><li>Here are some important concepts about yatp 1. TaskInjector:it&#39;s a global queue for new tasks . When a new task is injected into yatp,firstly, it will past the prepare_before_push to adjust the priority level. Secondly, push task into that level queue. 2. thread::Builder::new().name(name) will construct the thread number of local_queues in LazyBuilder::build. 3.</li></ol><p>LazyWorker --&gt; Worker --&gt; Builder --&gt; YatpPoolBuilder --&gt; yatp::Builder(build_single_level_pool) init_servers --&gt; unified_read_pool --&gt; build_yatp_read_pool --&gt; build_multi_level_pool</p><p>In TiKV :</p><ol><li><p>We can see Worker::create is used to create a yatp thread pool,and Worker::lazy_build is to build some worker aiming for a specific function,like backup-endpoint ,which is a very important gate to see more details about the backup worker.</p></li><li><p>Worker : A worker that can schedule time consuming tasks, including some functions like new, start, start_with_timer, lazy_build ...</p></li><li><p>Builder : the main function is to init some yapt threads and return a struct of Worker.</p></li><li><p>Function start and start_with_timer: the main functions are to init different schedulers with different functions,like timer or tick(ping).in short,it&#39;s used to add channel to communicate and exchange messages.</p></li><li><p>Function start_impl and start_with_timer_impl` : they are the actual actions to spawn a thread and commit tasks into it.</p></li><li><p>There&#39;s an important trait named Runnable for Endpoint and one of functions named Run() representing how to run a task for a specific worker.</p></li></ol>',9)]))}const b=t(i,[["render",s]]);export{h as __pageData,b as default};
