import{_ as a,c as l,a4 as i,o as e}from"./chunks/framework.C3yiUNUH.js";const o="/assets/3-1.tikv.01.BCpGv5aP.jpg",r="/assets/3-1.tikv.02.C7aiyH8k.jpg",s="/assets/3-1.tikv.03.CEhyCxDB.jpg",c="/assets/3-1.tikv.04.DaDsGwlz.jpg",k=JSON.parse('{"title":"TIKV 监控面板 - Allocator Stats","description":"","frontmatter":{},"headers":[],"relativePath":"zh/work/tidb/03TiDB-运维管理/3-2TiKV 监控详解/TIKV 监控面板 - Allocator Stats.md","filePath":"zh/work/tidb/03TiDB-运维管理/3-2TiKV 监控详解/TIKV 监控面板 - Allocator Stats.md"}'),n={name:"zh/work/tidb/03TiDB-运维管理/3-2TiKV 监控详解/TIKV 监控面板 - Allocator Stats.md"};function g(m,t,d,p,h,f){return e(),l("div",null,t[0]||(t[0]=[i('<h1 id="tikv-监控面板-allocator-stats" tabindex="-1">TIKV 监控面板 - Allocator Stats <a class="header-anchor" href="#tikv-监控面板-allocator-stats" aria-label="Permalink to &quot;TIKV 监控面板 - Allocator Stats&quot;">​</a></h1><h2 id="_1-面板简介" tabindex="-1">1. 面板简介 <a class="header-anchor" href="#_1-面板简介" aria-label="Permalink to &quot;1. 面板简介&quot;">​</a></h2><p>        简而言之，Jemalloc 是一个通用的 malloc(3) 实现，着重于减少内存碎片和提高多线程并发性能，TiKV 使用 Jemalloc 管理内存。TiKV 的 Allocator Stats 面板对分析 TiKV 内存消耗至关重要。</p><figure><img src="'+o+'" alt="3-1.tikv.01" tabindex="0"><figcaption>3-1.tikv.01</figcaption></figure><h2 id="_2-面板位置" tabindex="-1">2. 面板位置 <a class="header-anchor" href="#_2-面板位置" aria-label="Permalink to &quot;2. 面板位置&quot;">​</a></h2><blockquote><p>Cluster-TiKV-Details --&gt; Memory --&gt; Allocator Stats</p></blockquote><figure><img src="'+r+'" alt="3-1.tikv.02" tabindex="0"><figcaption>3-1.tikv.02</figcaption></figure><h2 id="_3-面板详情" tabindex="-1">3. 面板详情 <a class="header-anchor" href="#_3-面板详情" aria-label="Permalink to &quot;3. 面板详情&quot;">​</a></h2><p>类型如下：</p><ul><li>mapped</li><li>resident</li><li>active</li><li>allocated</li><li>fragmentation</li><li>metadata</li><li>retained</li><li>dirty</li></ul><hr><ol><li><strong>allocated</strong> : Jemalloc 接到 APP 申请的物理内存总字节数。</li><li><strong>active</strong> : Jemalloc 为进程分配的物理内存总字节数，通常 active &gt;= allocated，表示已分配且正在使用的内存。</li><li><strong>metadata</strong> : Jemalloc 为管理内存额外的 metadata 物理内存消耗。</li><li><strong>mapped</strong> : Jemalloc 映射的内存总字节数，mapped &gt; active(为 APP 映射的)。</li><li><strong>resident</strong> : Jemalloc 从当前实际驻留在物理内存中的内存量。即：通过系统调用从操作系统申请的 OS 内存，反映了实际占用物理内存的大小。</li><li><strong>retained</strong> : Jemalloc 保留的虚拟内存(virtual memory)映射大小，与物理内存（physical memory）没有强关系。</li><li><strong>dirty</strong> : <strong>resident - active - metadata</strong>, 一个物理内存区域被分配又被释放，说明可以被 Jemalloc GC 了，就是“脏”的。Jemalloc 会定期用 madvise() 清理脏页，会经历 dirty -&gt; muzzy -&gt; retained 的过程。</li><li><strong>fragmentation</strong> : <strong>active - allocated</strong>, 代表内存碎片(内部碎片 + 外部碎片)的占用情况。</li></ol><figure><img src="'+s+'" alt="3-1.tikv.03" tabindex="0"><figcaption>3-1.tikv.03</figcaption></figure><p>         一个经典的场景，如果 TiKV 在 Region 均衡的前提下，内存高度不均衡（GB 级别）有可能是内存碎片导致的，如下图所示。</p><figure><img src="'+c+'" alt="3-1.tikv.04" tabindex="0"><figcaption>3-1.tikv.04</figcaption></figure><h2 id="_4-参考文献" tabindex="-1">4. 参考文献 <a class="header-anchor" href="#_4-参考文献" aria-label="Permalink to &quot;4. 参考文献&quot;">​</a></h2><ol><li><a href="https://jemalloc.net/jemalloc.3.html#stats.active" target="_blank" rel="noreferrer">jemalloc doc</a></li><li><a href="https://github.com/tikv/tikv/blob/568b414e99bebf118eedd9b50f24f299efbcab79/components/tikv_alloc/src/jemalloc.rs#L169-L189" target="_blank" rel="noreferrer">tikv code addr</a></li><li><a href="https://youjiali1995.github.io/allocator/jemalloc" target="_blank" rel="noreferrer">youjiali blog</a></li><li><a href="https://zhuanlan.zhihu.com/p/48957114" target="_blank" rel="noreferrer">Jemalloc analysis</a></li><li><a href="https://www.youtube.com/watch?v=RcWp5vwGlYU&amp;list=PLn0nrSd4xjjZoaFwsTnmS1UFj3ob7gf7s" target="_blank" rel="noreferrer">Tick Tock, malloc Needs a Clock</a></li></ol>',17)]))}const u=a(n,[["render",g]]);export{k as __pageData,u as default};
