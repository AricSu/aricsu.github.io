import{_ as t,c as r,o,a4 as a}from"./chunks/framework.svyMRVY3.js";const p=JSON.parse('{"title":"Metrics","description":"","frontmatter":{},"headers":[],"relativePath":"zh/work/tidb/TiDB-EcosystematicTools/5-4DM/06TiDB-DM Metrics.md","filePath":"zh/work/tidb/TiDB-EcosystematicTools/5-4DM/06TiDB-DM Metrics.md"}'),n={name:"zh/work/tidb/TiDB-EcosystematicTools/5-4DM/06TiDB-DM Metrics.md"};function i(s,e,l,c,d,g){return o(),r("div",null,e[0]||(e[0]=[a(`<h1 id="metrics" tabindex="-1">Metrics <a class="header-anchor" href="#metrics" aria-label="Permalink to &quot;Metrics&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><h2 id="operate-error" tabindex="-1">operate error <a class="header-anchor" href="#operate-error" aria-label="Permalink to &quot;operate error&quot;">​</a></h2><h2 id="ha" tabindex="-1">HA <a class="header-anchor" href="#ha" aria-label="Permalink to &quot;HA&quot;">​</a></h2><ol><li><strong>每分钟dm-master启动领导组件的数量</strong><br><strong>a. 含义</strong> : 每分钟dm-master尝试启动leader组件的个数 <strong>b. 计算</strong> :</li></ol><h2 id="task" tabindex="-1">task <a class="header-anchor" href="#task" aria-label="Permalink to &quot;task&quot;">​</a></h2><h2 id="load-dump-files" tabindex="-1">load dump files <a class="header-anchor" href="#load-dump-files" aria-label="Permalink to &quot;load dump files&quot;">​</a></h2><h2 id="binlog-replication" tabindex="-1">binlog replication <a class="header-anchor" href="#binlog-replication" aria-label="Permalink to &quot;binlog replication&quot;">​</a></h2><ol><li><p><strong>remaining time to sync</strong><br><strong>a. Meaning</strong> :<br><strong>b. Colculation</strong> : it&#39;s calculated by expr below:</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    remainingSize =</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">remainingSeconds = ---------------------------------------------------------------</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    bytesPerSec  =  (totalBinlogSize - lastBinlogSize) / seconds</span></span></code></pre></div></li><li><p><strong>replicate lag</strong><br><strong>a. Meaning</strong> : The latency time it takes to replicate the binlog from master to Syncer (in seconds)<br><strong>b. Colculation</strong> : In this <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/syncer/syncer.go#L890" target="_blank" rel="noreferrer">func updateReplicationLagMetric</a>, the metric is updated by ticking per 100ms. the <code>lag</code> is calculated in an expression of <code>time.Now().Unix() - s.tsOffset.Load() - headerTS</code>. which <code>tsOffset</code> represents time range between upstream and syncer, DM&#39;s timestamp - MySQL&#39;s timestamp, and <code>headerTS</code> is minior timestamp,which is binlog <code>EventHeader Timestamp</code> parsed by <a href="https://github.com/go-mysql-org/go-mysql/tree/master/replication" target="_blank" rel="noreferrer">go-mysql-org/go-mysql/replication</a>, of every DM worker MySQL.</p></li><li><p><strong>process exits with error</strong><br><strong>a. Meaning</strong> : The binlog replication unit process encounters an error within the DM-worker and exits<br><strong>b. Colculation</strong> : 1</p></li><li><p><strong>binlog file gap between master and syncer</strong><br><strong>a. Meaning</strong> : The number of binlog files in binlog replication unit that are behind the master.<br><strong>b. Colculation</strong> : <strong>For <code>master</code></strong>,</p></li><li><p><strong>binlog file gap between relay and syncer</strong></p></li><li><p><strong>binlog event QPS</strong></p></li><li><p><strong>skipped binlog event QPS</strong></p></li><li><p><strong>read binlog event duration</strong></p></li><li><p><strong>transform binlog event duration</strong><br><strong>a. Meaning</strong> : The time it takes binlog replication unit to parse and transform the binlog into SQL statements (in seconds)<br><strong>b. Colculation</strong> : At <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/syncer/syncer.go#L1504" target="_blank" rel="noreferrer">func successFunc</a>, every job will have calculated the duration in DDLWorker and DMLWorker executing <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/syncer/dml_worker.go#L200" target="_blank" rel="noreferrer">func executeBatchJobs</a>, since raw binlog had tranformed into Syncer dealing loop function. And It has 90%, 95% and 99% quantile curve.</p></li><li><p><strong>dispatch binlog event duration</strong></p></li><li><p><strong>transaction execution latency</strong></p></li><li><p><strong>binlog event size</strong><br><strong>a. Meaning</strong> : The size of a single binlog event that the binlog replication unit reads from relay log or upstream master.<br><strong>b. Colculation</strong> : At <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/syncer/syncer.go#L2159" target="_blank" rel="noreferrer">here</a>, Syncer&#39;ll record every binlog event_size in event header from <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/syncer/binlogstream/streamer_controller.go#L131" target="_blank" rel="noreferrer">binlogstream</a>. So, in grafana, DM uses a type of histogram to draw a quantile curve, including 90%, 95%, 99%.</p></li><li><p><strong>DML queue remain length</strong><br><strong>a. Meaning</strong> : The remain length of DML job queues, which have <code>causality_input</code>, <code>compactor_input</code>, <code>dml_worker_input</code>, <code>q_number</code>,number is calculated in <code>queueID%defaultBucketCount</code>.<br><strong>b. Colculation</strong> : <strong>For <code>causality_input</code></strong> : Causality provides a simple mechanism to improve the concurrency of SQLs execution under the premise of ensuring correctness, which groups sqls that maybe contain causal relationships, and syncer executes them linearly, <a href="https://github.com/pingcap/tiflow/blob/211e6e7d5fa0944d1f5e0ad585cb8549d5604395/dm/docs/RFCS/20211012_async_checkpoint_flush.md#causality-optimization" target="_blank" rel="noreferrer">more details</a>. So, it records the number of causality component is keeping about rows. <strong>For <code>dml_worker_input</code></strong> : which means how many jobs were sent to DMWorker. <strong>For <code>compactor_input</code></strong> : it&#39;ll equal to the function of causality_input if you config <a href="https://docs.pingcap.com/zh/tidb/v6.6/dm-dml-replication-logic#compactor" target="_blank" rel="noreferrer">this feature</a>. <strong>For <code>q_number</code></strong> : all DMLs at <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/syncer/dml_worker.go#L100" target="_blank" rel="noreferrer">here</a> will be distributed into different queues(default 8) and when they are executed in <a href="https://github.com/pingcap/tiflow/blob/c65e2b72198de10319008b31dcf13d51509ccfde/dm/syncer/dml_worker.go#L159" target="_blank" rel="noreferrer">DMLWorker&#39;s executeJobs</a>, it&#39;ll be recorded by the queue name.</p></li></ol><h2 id="relay-log" tabindex="-1">relay log <a class="header-anchor" href="#relay-log" aria-label="Permalink to &quot;relay log&quot;">​</a></h2>`,10)]))}const b=t(n,[["render",i]]);export{p as __pageData,b as default};
