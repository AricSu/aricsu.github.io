import {createRequire as __createRequire} from 'module';var require=__createRequire(import.meta.url);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports, module) {
    var p = process || {};
    var argv = p.argv || [];
    var env = p.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module.exports = createColors();
    module.exports.createColors = createColors;
  }
});

// node_modules/.pnpm/shell-quote@1.8.2/node_modules/shell-quote/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/shell-quote@1.8.2/node_modules/shell-quote/parse.js"(exports, module) {
    "use strict";
    var CONTROL = "(?:" + [
      "\\|\\|",
      "\\&\\&",
      ";;",
      "\\|\\&",
      "\\<\\(",
      "\\<\\<\\<",
      ">>",
      ">\\&",
      "<\\&",
      "[&;()|<>]"
    ].join("|") + ")";
    var controlRE = new RegExp("^" + CONTROL + "$");
    var META = "|&;()<> \\t";
    var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    var hash = /^#$/;
    var SQ = "'";
    var DQ = '"';
    var DS = "$";
    var TOKEN = "";
    var mult = 4294967296;
    for (i = 0; i < 4; i++) {
      TOKEN += (mult * Math.random()).toString(16);
    }
    var i;
    var startsWithToken = new RegExp("^" + TOKEN);
    function matchAll(s, r) {
      var origIndex = r.lastIndex;
      var matches = [];
      var matchObj;
      while (matchObj = r.exec(s)) {
        matches.push(matchObj);
        if (r.lastIndex === matchObj.index) {
          r.lastIndex += 1;
        }
      }
      r.lastIndex = origIndex;
      return matches;
    }
    function getVar(env, pre, key) {
      var r = typeof env === "function" ? env(key) : env[key];
      if (typeof r === "undefined" && key != "") {
        r = "";
      } else if (typeof r === "undefined") {
        r = "$";
      }
      if (typeof r === "object") {
        return pre + TOKEN + JSON.stringify(r) + TOKEN;
      }
      return pre + r;
    }
    function parseInternal(string, env, opts) {
      if (!opts) {
        opts = {};
      }
      var BS = opts.escape || "\\";
      var BAREWORD = "(\\" + BS + `['"` + META + `]|[^\\s'"` + META + "])+";
      var chunker = new RegExp([
        "(" + CONTROL + ")",
        // control chars
        "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")+"
      ].join("|"), "g");
      var matches = matchAll(string, chunker);
      if (matches.length === 0) {
        return [];
      }
      if (!env) {
        env = {};
      }
      var commented = false;
      return matches.map(function(match) {
        var s = match[0];
        if (!s || commented) {
          return void 0;
        }
        if (controlRE.test(s)) {
          return { op: s };
        }
        var quote = false;
        var esc = false;
        var out = "";
        var isGlob = false;
        var i2;
        function parseEnvVar() {
          i2 += 1;
          var varend;
          var varname;
          var char = s.charAt(i2);
          if (char === "{") {
            i2 += 1;
            if (s.charAt(i2) === "}") {
              throw new Error("Bad substitution: " + s.slice(i2 - 2, i2 + 1));
            }
            varend = s.indexOf("}", i2);
            if (varend < 0) {
              throw new Error("Bad substitution: " + s.slice(i2));
            }
            varname = s.slice(i2, varend);
            i2 = varend;
          } else if (/[*@#?$!_-]/.test(char)) {
            varname = char;
            i2 += 1;
          } else {
            var slicedFromI = s.slice(i2);
            varend = slicedFromI.match(/[^\w\d_]/);
            if (!varend) {
              varname = slicedFromI;
              i2 = s.length;
            } else {
              varname = slicedFromI.slice(0, varend.index);
              i2 += varend.index - 1;
            }
          }
          return getVar(env, "", varname);
        }
        for (i2 = 0; i2 < s.length; i2++) {
          var c4 = s.charAt(i2);
          isGlob = isGlob || !quote && (c4 === "*" || c4 === "?");
          if (esc) {
            out += c4;
            esc = false;
          } else if (quote) {
            if (c4 === quote) {
              quote = false;
            } else if (quote == SQ) {
              out += c4;
            } else {
              if (c4 === BS) {
                i2 += 1;
                c4 = s.charAt(i2);
                if (c4 === DQ || c4 === BS || c4 === DS) {
                  out += c4;
                } else {
                  out += BS + c4;
                }
              } else if (c4 === DS) {
                out += parseEnvVar();
              } else {
                out += c4;
              }
            }
          } else if (c4 === DQ || c4 === SQ) {
            quote = c4;
          } else if (controlRE.test(c4)) {
            return { op: s };
          } else if (hash.test(c4)) {
            commented = true;
            var commentObj = { comment: string.slice(match.index + i2 + 1) };
            if (out.length) {
              return [out, commentObj];
            }
            return [commentObj];
          } else if (c4 === BS) {
            esc = true;
          } else if (c4 === DS) {
            out += parseEnvVar();
          } else {
            out += c4;
          }
        }
        if (isGlob) {
          return { op: "glob", pattern: out };
        }
        return out;
      }).reduce(function(prev, arg) {
        return typeof arg === "undefined" ? prev : prev.concat(arg);
      }, []);
    }
    module.exports = function parse2(s, env, opts) {
      var mapped = parseInternal(s, env, opts);
      if (typeof env !== "function") {
        return mapped;
      }
      return mapped.reduce(function(acc, s2) {
        if (typeof s2 === "object") {
          return acc.concat(s2);
        }
        var xs = s2.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
        if (xs.length === 1) {
          return acc.concat(xs[0]);
        }
        return acc.concat(xs.filter(Boolean).map(function(x5) {
          if (startsWithToken.test(x5)) {
            return JSON.parse(x5.split(TOKEN)[1]);
          }
          return x5;
        }));
      }, []);
    };
  }
});

// node_modules/.pnpm/log-symbols@7.0.0/node_modules/log-symbols/symbols.js
var symbols_exports = {};
__export(symbols_exports, {
  error: () => error,
  info: () => info,
  success: () => success,
  warning: () => warning
});

// node_modules/.pnpm/yoctocolors@2.1.1/node_modules/yoctocolors/base.js
import tty from "node:tty";
var _a, _b, _c, _d, _e;
var hasColors = (_e = (_d = (_c = (_b = (_a = tty) == null ? void 0 : _a.WriteStream) == null ? void 0 : _b.prototype) == null ? void 0 : _c.hasColors) == null ? void 0 : _d.call(_c)) != null ? _e : false;
var format = (open, close) => {
  if (!hasColors) {
    return (input) => input;
  }
  const openCode = `\x1B[${open}m`;
  const closeCode = `\x1B[${close}m`;
  return (input) => {
    const string = input + "";
    let index = string.indexOf(closeCode);
    if (index === -1) {
      return openCode + string + closeCode;
    }
    let result = openCode;
    let lastIndex = 0;
    while (index !== -1) {
      result += string.slice(lastIndex, index) + openCode;
      lastIndex = index + closeCode.length;
      index = string.indexOf(closeCode, lastIndex);
    }
    result += string.slice(lastIndex) + closeCode;
    return result;
  };
};
var reset = format(0, 0);
var bold = format(1, 22);
var dim = format(2, 22);
var italic = format(3, 23);
var underline = format(4, 24);
var overline = format(53, 55);
var inverse = format(7, 27);
var hidden = format(8, 28);
var strikethrough = format(9, 29);
var black = format(30, 39);
var red = format(31, 39);
var green = format(32, 39);
var yellow = format(33, 39);
var blue = format(34, 39);
var magenta = format(35, 39);
var cyan = format(36, 39);
var white = format(37, 39);
var gray = format(90, 39);
var bgBlack = format(40, 49);
var bgRed = format(41, 49);
var bgGreen = format(42, 49);
var bgYellow = format(43, 49);
var bgBlue = format(44, 49);
var bgMagenta = format(45, 49);
var bgCyan = format(46, 49);
var bgWhite = format(47, 49);
var bgGray = format(100, 49);
var redBright = format(91, 39);
var greenBright = format(92, 39);
var yellowBright = format(93, 39);
var blueBright = format(94, 39);
var magentaBright = format(95, 39);
var cyanBright = format(96, 39);
var whiteBright = format(97, 39);
var bgRedBright = format(101, 49);
var bgGreenBright = format(102, 49);
var bgYellowBright = format(103, 49);
var bgBlueBright = format(104, 49);
var bgMagentaBright = format(105, 49);
var bgCyanBright = format(106, 49);
var bgWhiteBright = format(107, 49);

// node_modules/.pnpm/is-unicode-supported@2.1.0/node_modules/is-unicode-supported/index.js
import process2 from "node:process";
function isUnicodeSupported() {
  const { env } = process2;
  const { TERM, TERM_PROGRAM } = env;
  if (process2.platform !== "win32") {
    return TERM !== "linux";
  }
  return Boolean(env.WT_SESSION) || Boolean(env.TERMINUS_SUBLIME) || env.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/.pnpm/log-symbols@7.0.0/node_modules/log-symbols/symbols.js
var _isUnicodeSupported = isUnicodeSupported();
var info = blue(_isUnicodeSupported ? "\u2139" : "i");
var success = green(_isUnicodeSupported ? "\u2714" : "\u221A");
var warning = yellow(_isUnicodeSupported ? "\u26A0" : "\u203C");
var error = red(_isUnicodeSupported ? "\u2716\uFE0F" : "\xD7");

// src/release-type.ts
var prereleaseTypes = ["premajor", "preminor", "prepatch", "prerelease"];
var releaseTypes = prereleaseTypes.concat(["major", "minor", "patch", "next"]);
function isPrerelease(value) {
  return prereleaseTypes.includes(value);
}
function isReleaseType(value) {
  return releaseTypes.includes(value);
}

// src/types/version-bump-progress.ts
var ProgressEvent = /* @__PURE__ */ ((ProgressEvent2) => {
  ProgressEvent2["FileUpdated"] = "file updated";
  ProgressEvent2["FileSkipped"] = "file skipped";
  ProgressEvent2["GitCommit"] = "git commit";
  ProgressEvent2["GitTag"] = "git tag";
  ProgressEvent2["GitPush"] = "git push";
  ProgressEvent2["NpmScript"] = "npm script";
  return ProgressEvent2;
})(ProgressEvent || {});
var NpmScript = /* @__PURE__ */ ((NpmScript2) => {
  NpmScript2["PreVersion"] = "preversion";
  NpmScript2["Version"] = "version";
  NpmScript2["PostVersion"] = "postversion";
  return NpmScript2;
})(NpmScript || {});

// src/version-bump.ts
import process5 from "node:process";
var import_picocolors3 = __toESM(require_picocolors());
var import_parse = __toESM(require_parse());
import prompts2 from "prompts";
import { x as x4 } from "tinyexec";

// src/get-current-version.ts
import { valid as isValidVersion } from "semver";

// src/fs.ts
import fs from "node:fs";
import path from "node:path";
import * as jsonc from "jsonc-parser";
async function readJsoncFile(name, cwd) {
  const file = await readTextFile(name, cwd);
  const data = jsonc.parse(file.data);
  const modified = [];
  return __spreadProps(__spreadValues({}, file), { data, modified, text: file.data });
}
async function writeJsoncFile(file) {
  let newJSON = file.text;
  for (const [key, value] of file.modified) {
    const edit = jsonc.modify(file.text, key, value, {});
    newJSON = jsonc.applyEdits(newJSON, edit);
  }
  return writeTextFile(__spreadProps(__spreadValues({}, file), { data: newJSON }));
}
function readTextFile(name, cwd) {
  return new Promise((resolve, reject) => {
    const filePath = path.join(cwd, name);
    fs.readFile(filePath, "utf8", (err, text) => {
      if (err) {
        reject(err);
      } else {
        resolve({
          path: filePath,
          data: text
        });
      }
    });
  });
}
function writeTextFile(file) {
  return new Promise((resolve, reject) => {
    fs.writeFile(file.path, file.data, (err) => {
      if (err)
        reject(err);
      else
        resolve();
    });
  });
}

// src/manifest.ts
function isManifest(obj) {
  return obj && typeof obj === "object" && isOptionalString(obj.name) && isOptionalString(obj.version) && isOptionalString(obj.description);
}
function isPackageLockManifest(manifest) {
  var _a2, _b2;
  return typeof ((_b2 = (_a2 = manifest.packages) == null ? void 0 : _a2[""]) == null ? void 0 : _b2.version) === "string";
}
function isOptionalString(value) {
  const type = typeof value;
  return value === null || type === "undefined" || type === "string";
}

// src/get-current-version.ts
async function getCurrentVersion(operation) {
  if (operation.state.currentVersion)
    return operation;
  const { cwd, files } = operation.options;
  const filesToCheck = files.filter((file) => file.endsWith(".json"));
  if (!filesToCheck.includes("package.json"))
    filesToCheck.push("package.json");
  if (!filesToCheck.includes("deno.json"))
    filesToCheck.push("deno.json");
  if (!filesToCheck.includes("deno.jsonc"))
    filesToCheck.push("deno.jsonc");
  for (const file of filesToCheck) {
    const version = await readVersion(file, cwd);
    if (version) {
      return operation.update({
        currentVersionSource: file,
        currentVersion: version
      });
    }
  }
  throw new Error(
    `Unable to determine the current version number. Checked ${filesToCheck.join(", ")}.`
  );
}
async function readVersion(file, cwd) {
  try {
    const { data: manifest } = await readJsoncFile(file, cwd);
    if (isManifest(manifest)) {
      if (isValidVersion(manifest.version))
        return manifest.version;
    }
  } catch (e) {
    return void 0;
  }
}

// src/get-new-version.ts
var import_picocolors2 = __toESM(require_picocolors());
import process3 from "node:process";
import prompts from "prompts";
import semver, { clean as cleanVersion, valid as isValidVersion2, SemVer } from "semver";

// src/print-commits.ts
var import_picocolors = __toESM(require_picocolors());
import { x } from "tinyexec";
var messageColorMap = {
  chore: import_picocolors.default.gray,
  fix: import_picocolors.default.yellow,
  feat: import_picocolors.default.green,
  refactor: import_picocolors.default.cyan,
  docs: import_picocolors.default.blue,
  doc: import_picocolors.default.blue,
  ci: import_picocolors.default.gray,
  build: import_picocolors.default.gray
};
function parseCommits(raw) {
  const lines = raw.toString().trim().split(/\n/g);
  if (!lines.length) {
    return [];
  }
  return lines.map((line) => {
    const [hash, ...parts] = line.split(" ");
    const message = parts.join(" ");
    const match = message.match(/^(\w+)(!)?(\([^)]+\))?(!)?:(.*)$/);
    if (match) {
      let color = messageColorMap[match[1].toLowerCase()] || ((c4) => c4);
      const breaking = match[2] === "!" || match[4] === "!";
      if (breaking) {
        color = (s) => import_picocolors.default.inverse(import_picocolors.default.red(s));
      }
      const tag = [match[1], match[2], match[4]].filter(Boolean).join("");
      const scope = match[3] || "";
      return {
        hash,
        tag,
        message: match[5].trim(),
        scope,
        breaking,
        color
      };
    }
    return {
      hash,
      tag: "",
      message,
      scope: "",
      color: (c4) => c4
    };
  }).reverse();
}
function formatParsedCommits(commits) {
  const tagLength = commits.map(({ tag }) => tag.length).reduce((a, b) => Math.max(a, b), 0);
  let scopeLength = commits.map(({ scope }) => scope.length).reduce((a, b) => Math.max(a, b), 0);
  if (scopeLength)
    scopeLength += 2;
  return commits.map(({ hash, tag, message, scope, color }) => {
    const paddedTag = tag.padStart(tagLength + 1, " ");
    const paddedScope = !scope ? " ".repeat(scopeLength) : import_picocolors.default.dim("(") + scope.slice(1, -1) + import_picocolors.default.dim(")") + " ".repeat(scopeLength - scope.length);
    return [
      import_picocolors.default.dim(hash),
      " ",
      color === import_picocolors.default.gray ? color(paddedTag) : import_picocolors.default.bold(color(paddedTag)),
      " ",
      paddedScope,
      import_picocolors.default.dim(":"),
      " ",
      color === import_picocolors.default.gray ? color(message) : message
    ].join("");
  });
}
async function printRecentCommits(operation) {
  let sha;
  sha || (sha = await x(
    "git",
    ["rev-list", "-n", "1", `v${operation.state.currentVersion}`],
    { nodeOptions: { stdio: "pipe" }, throwOnError: false }
  ).then((res) => res.stdout.trim()));
  sha || (sha = await x(
    "git",
    ["rev-list", "-n", "1", operation.state.currentVersion],
    { nodeOptions: { stdio: "pipe" }, throwOnError: false }
  ).then((res) => res.stdout.trim()));
  if (!sha) {
    console.log(
      import_picocolors.default.blue(`i`) + import_picocolors.default.gray(` Failed to locate the previous tag ${import_picocolors.default.yellow(`v${operation.state.currentVersion}`)}`)
    );
    return;
  }
  const { stdout } = await x(
    "git",
    [
      "--no-pager",
      "log",
      `${sha}..HEAD`,
      "--oneline"
    ],
    {
      nodeOptions: {
        stdio: "pipe"
      }
    }
  );
  const parsed = parseCommits(stdout.toString().trim());
  const prettified = formatParsedCommits(parsed);
  if (!parsed.length) {
    console.log();
    console.log(import_picocolors.default.blue(`i`) + import_picocolors.default.gray(` No commits since ${operation.state.currentVersion}`));
    console.log();
    return;
  }
  console.log();
  console.log(
    import_picocolors.default.bold(
      `${import_picocolors.default.green(parsed.length)} Commits since ${import_picocolors.default.gray(sha.slice(0, 7))}:`
    )
  );
  console.log();
  console.log(prettified.join("\n"));
  console.log();
}

// src/get-new-version.ts
async function getNewVersion(operation) {
  const { release } = operation.options;
  const { currentVersion } = operation.state;
  switch (release.type) {
    case "prompt":
      return promptForNewVersion(operation);
    case "version":
      return operation.update({
        newVersion: new SemVer(release.version, true).version
      });
    default:
      return operation.update({
        release: release.type,
        newVersion: getNextVersion(currentVersion, release)
      });
  }
}
function getNextVersion(currentVersion, bump) {
  const oldSemVer = new SemVer(currentVersion);
  const type = bump.type === "next" ? oldSemVer.prerelease.length ? "prerelease" : "patch" : bump.type;
  const newSemVer = oldSemVer.inc(type, bump.preid);
  if (isPrerelease(bump.type) && newSemVer.prerelease.length === 2 && newSemVer.prerelease[0] === bump.preid && String(newSemVer.prerelease[1]) === "0") {
    newSemVer.prerelease[1] = "1";
    newSemVer.format();
  }
  return newSemVer.version;
}
function getNextVersions(currentVersion, preid) {
  const next = {};
  const parse2 = semver.parse(currentVersion);
  if (typeof (parse2 == null ? void 0 : parse2.prerelease[0]) === "string")
    preid = (parse2 == null ? void 0 : parse2.prerelease[0]) || "preid";
  for (const type of releaseTypes)
    next[type] = getNextVersion(currentVersion, { type, preid });
  return next;
}
async function promptForNewVersion(operation) {
  var _a2, _b2;
  const { currentVersion } = operation.state;
  const release = operation.options.release;
  const next = getNextVersions(currentVersion, release.preid);
  const configCustomVersion = await ((_b2 = (_a2 = operation.options).customVersion) == null ? void 0 : _b2.call(_a2, currentVersion, semver));
  if (operation.options.printCommits) {
    await printRecentCommits(operation);
  }
  const PADDING = 13;
  const answers = await prompts([
    {
      type: "autocomplete",
      name: "release",
      message: `Current version ${import_picocolors2.default.green(currentVersion)}`,
      initial: configCustomVersion ? "config" : "next",
      choices: [
        { value: "major", title: `${"major".padStart(PADDING, " ")} ${import_picocolors2.default.bold(next.major)}` },
        { value: "minor", title: `${"minor".padStart(PADDING, " ")} ${import_picocolors2.default.bold(next.minor)}` },
        { value: "patch", title: `${"patch".padStart(PADDING, " ")} ${import_picocolors2.default.bold(next.patch)}` },
        { value: "next", title: `${"next".padStart(PADDING, " ")} ${import_picocolors2.default.bold(next.next)}` },
        ...configCustomVersion ? [
          { value: "config", title: `${"from config".padStart(PADDING, " ")} ${import_picocolors2.default.bold(configCustomVersion)}` }
        ] : [],
        { value: "prepatch", title: `${"pre-patch".padStart(PADDING, " ")} ${import_picocolors2.default.bold(next.prepatch)}` },
        { value: "preminor", title: `${"pre-minor".padStart(PADDING, " ")} ${import_picocolors2.default.bold(next.preminor)}` },
        { value: "premajor", title: `${"pre-major".padStart(PADDING, " ")} ${import_picocolors2.default.bold(next.premajor)}` },
        { value: "none", title: `${"as-is".padStart(PADDING, " ")} ${import_picocolors2.default.bold(currentVersion)}` },
        { value: "custom", title: "custom ...".padStart(PADDING + 4, " ") }
      ]
    },
    {
      type: (prev) => prev === "custom" ? "text" : null,
      name: "custom",
      message: "Enter the new version number:",
      initial: currentVersion,
      validate: (custom) => {
        return isValidVersion2(custom) ? true : "That's not a valid version number";
      }
    }
  ]);
  const newVersion = answers.release === "none" ? currentVersion : answers.release === "custom" ? cleanVersion(answers.custom) : answers.release === "config" ? cleanVersion(configCustomVersion) : next[answers.release];
  if (!newVersion)
    process3.exit(1);
  switch (answers.release) {
    case "custom":
    case "config":
    case "next":
    case "none":
      return operation.update({ newVersion });
    default:
      return operation.update({ release: answers.release, newVersion });
  }
}

// src/git.ts
import { x as x2 } from "tinyexec";
async function gitCommit(operation) {
  if (!operation.options.commit)
    return operation;
  const { all, noVerify, message } = operation.options.commit;
  const { updatedFiles, newVersion } = operation.state;
  let args = ["--allow-empty"];
  if (all) {
    args.push("--all");
  }
  if (noVerify) {
    args.push("--no-verify");
  }
  if (operation.options.sign) {
    args.push("--gpg-sign");
  }
  const commitMessage = formatVersionString(message, newVersion);
  args.push("--message", commitMessage);
  if (!all)
    args = args.concat(updatedFiles);
  await x2("git", ["commit", ...args]);
  return operation.update({ event: "git commit" /* GitCommit */, commitMessage });
}
async function gitTag(operation) {
  if (!operation.options.tag)
    return operation;
  const { commit, tag } = operation.options;
  const { newVersion } = operation.state;
  const args = [
    // Create an annotated tag, which is recommended for releases.
    // See https://git-scm.com/docs/git-tag
    "--annotate",
    // Use the same commit message for the tag
    "--message",
    formatVersionString(commit.message, newVersion)
  ];
  const tagName = formatVersionString(tag.name, newVersion);
  args.push(tagName);
  if (operation.options.sign) {
    args.push("--sign");
  }
  await x2("git", ["tag", ...args]);
  return operation.update({ event: "git tag" /* GitTag */, tagName });
}
async function gitPush(operation) {
  if (!operation.options.push)
    return operation;
  await x2("git", ["push"]);
  if (operation.options.tag) {
    await x2("git", ["push", "--tags"]);
  }
  return operation.update({ event: "git push" /* GitPush */ });
}
function formatVersionString(template, newVersion) {
  if (template.includes("%s"))
    return template.replace(/%s/g, newVersion);
  else
    return template + newVersion;
}

// src/normalize-options.ts
import fsSync from "node:fs";
import fs2 from "node:fs/promises";
import process4 from "node:process";
import yaml from "js-yaml";
import { glob } from "tinyglobby";
async function normalizeOptions(raw) {
  var _a2, _b2, _d2;
  const preid = typeof raw.preid === "string" ? raw.preid : "beta";
  const sign = Boolean(raw.sign);
  const push = Boolean(raw.push);
  const all = Boolean(raw.all);
  const noVerify = Boolean(raw.noVerify);
  const cwd = raw.cwd || process4.cwd();
  const ignoreScripts = Boolean(raw.ignoreScripts);
  const execute = raw.execute;
  const recursive = Boolean(raw.recursive);
  let release;
  if (!raw.release || raw.release === "prompt")
    release = { type: "prompt", preid };
  else if (isReleaseType(raw.release) || raw.release === "next")
    release = { type: raw.release, preid };
  else
    release = { type: "version", version: raw.release };
  let tag;
  if (typeof raw.tag === "string")
    tag = { name: raw.tag };
  else if (raw.tag)
    tag = { name: "v" };
  let commit;
  if (typeof raw.commit === "string")
    commit = { all, noVerify, message: raw.commit };
  else if (raw.commit || tag || push)
    commit = { all, noVerify, message: "chore: release v" };
  if (recursive && !((_a2 = raw.files) == null ? void 0 : _a2.length)) {
    raw.files = [
      "package.json",
      "package-lock.json",
      "packages/**/package.json",
      "jsr.json",
      "jsr.jsonc",
      "deno.json",
      "deno.jsonc"
    ];
    if (fsSync.existsSync("pnpm-workspace.yaml")) {
      const pnpmWorkspace = await fs2.readFile("pnpm-workspace.yaml", "utf8");
      const workspaces = yaml.load(pnpmWorkspace);
      const workspacesWithPackageJson = workspaces.packages.map((workspace) => `${workspace}/package.json`);
      const withoutExcludedWorkspaces = workspacesWithPackageJson.filter((workspace) => {
        var _a3;
        return !workspace.startsWith("!") && !((_a3 = raw.files) == null ? void 0 : _a3.includes(workspace));
      });
      raw.files = raw.files.concat(withoutExcludedWorkspaces);
    }
  } else {
    raw.files = ((_b2 = raw.files) == null ? void 0 : _b2.length) ? raw.files : ["package.json", "package-lock.json", "jsr.json", "jsr.jsonc", "deno.json", "deno.jsonc"];
  }
  const files = await glob(
    raw.files,
    {
      cwd,
      onlyFiles: true,
      expandDirectories: false,
      ignore: [
        "**/{.git,node_modules,bower_components,__tests__,fixtures,fixture}/**"
      ]
    }
  );
  let ui;
  if (raw.interface === false) {
    ui = { input: false, output: false };
  } else if (raw.interface === true || !raw.interface) {
    ui = { input: process4.stdin, output: process4.stdout };
  } else {
    let _c2 = raw.interface, { input, output } = _c2, other = __objRest(_c2, ["input", "output"]);
    if (input === true || input !== false && !input)
      input = process4.stdin;
    if (output === true || output !== false && !output)
      output = process4.stdout;
    ui = __spreadValues({ input, output }, other);
  }
  if (release.type === "prompt" && !(ui.input && ui.output))
    throw new Error("Cannot prompt for the version number because input or output has been disabled.");
  return {
    release,
    commit,
    tag,
    sign,
    push,
    files,
    cwd,
    interface: ui,
    ignoreScripts,
    execute,
    printCommits: (_d2 = raw.printCommits) != null ? _d2 : true,
    customVersion: raw.customVersion,
    currentVersion: raw.currentVersion
  };
}

// src/operation.ts
var Operation = class _Operation {
  /**
   * Private constructor.  Use the `Operation.start()` static method instead.
   */
  constructor(options, progress) {
    /**
     * The current state of the operation.
     */
    this.state = {
      release: void 0,
      currentVersion: "",
      currentVersionSource: "",
      newVersion: "",
      commitMessage: "",
      tagName: "",
      updatedFiles: [],
      skippedFiles: []
    };
    this.options = options;
    this._progress = progress;
    if (options.currentVersion) {
      this.update({
        currentVersion: options.currentVersion,
        currentVersionSource: "user"
      });
    }
  }
  /**
   * The results of the operation.
   */
  get results() {
    const options = this.options;
    const state = this.state;
    return {
      release: state.release,
      currentVersion: state.currentVersion,
      newVersion: state.newVersion,
      commit: options.commit ? state.commitMessage : false,
      tag: options.tag ? state.tagName : false,
      updatedFiles: state.updatedFiles.slice(),
      skippedFiles: state.skippedFiles.slice()
    };
  }
  /**
   * Starts a new `versionBump()` operation.
   */
  static async start(input) {
    const options = await normalizeOptions(input);
    return new _Operation(options, input.progress);
  }
  /**
   * Updates the operation state and results, and reports the updated progress to the user.
   */
  update(_a2) {
    var _b2 = _a2, { event, script } = _b2, newState = __objRest(_b2, ["event", "script"]);
    Object.assign(this.state, newState);
    if (event && this._progress) {
      this._progress(__spreadValues({ event, script }, this.results));
    }
    return this;
  }
};

// src/run-npm-script.ts
import { x as x3 } from "tinyexec";
async function runNpmScript(script, operation) {
  const { cwd, ignoreScripts } = operation.options;
  if (!ignoreScripts) {
    const { data: manifest } = await readJsoncFile("package.json", cwd);
    if (isManifest(manifest) && hasScript(manifest, script)) {
      await x3("npm", ["run", script, "--silent"], {
        nodeOptions: { stdio: "inherit" }
      });
      operation.update({ event: "npm script" /* NpmScript */, script });
    }
  }
  return operation;
}
function hasScript(manifest, script) {
  const scripts = manifest.scripts;
  if (scripts && typeof scripts === "object")
    return Boolean(scripts[script]);
  return false;
}

// src/update-files.ts
import { existsSync } from "node:fs";
import * as path2 from "node:path";
async function updateFiles(operation) {
  const { files } = operation.options;
  for (const relPath of files) {
    const modified = await updateFile(relPath, operation);
    if (modified) {
      operation.update({
        event: "file updated" /* FileUpdated */,
        updatedFiles: operation.state.updatedFiles.concat(relPath)
      });
    } else {
      operation.update({
        event: "file skipped" /* FileSkipped */,
        skippedFiles: operation.state.skippedFiles.concat(relPath)
      });
    }
  }
  return operation;
}
async function updateFile(relPath, operation) {
  if (!existsSync(relPath)) {
    return false;
  }
  const name = path2.basename(relPath).trim().toLowerCase();
  switch (name) {
    case "package.json":
    case "package-lock.json":
    case "bower.json":
    case "component.json":
    case "jsr.json":
    case "jsr.jsonc":
    case "deno.json":
    case "deno.jsonc":
      return updateManifestFile(relPath, operation);
    default:
      return updateTextFile(relPath, operation);
  }
}
async function updateManifestFile(relPath, operation) {
  const { cwd } = operation.options;
  const { newVersion } = operation.state;
  let modified = false;
  const file = await readJsoncFile(relPath, cwd);
  if (!isManifest(file.data)) {
    return modified;
  }
  if (file.data.version == null) {
    return modified;
  }
  if (file.data.version !== newVersion) {
    file.modified.push([["version"], newVersion]);
    if (isPackageLockManifest(file.data))
      file.modified.push([["packages", "", "version"], newVersion]);
    await writeJsoncFile(file);
    modified = true;
  }
  return modified;
}
async function updateTextFile(relPath, operation) {
  const { cwd } = operation.options;
  const { currentVersion, newVersion } = operation.state;
  const modified = false;
  const file = await readTextFile(relPath, cwd);
  if (file.data.includes(currentVersion)) {
    const sanitizedVersion = currentVersion.replace(/(\W)/g, "\\$1");
    const replacePattern = new RegExp(`(\\b|v)${sanitizedVersion}\\b`, "g");
    file.data = file.data.replace(replacePattern, `$1${newVersion}`);
    await writeTextFile(file);
    return true;
  }
  return modified;
}

// src/version-bump.ts
async function versionBump(arg = {}) {
  if (typeof arg === "string")
    arg = { release: arg };
  const operation = await Operation.start(arg);
  await getCurrentVersion(operation);
  await getNewVersion(operation);
  if (arg.confirm) {
    printSummary(operation);
    if (!await prompts2({
      name: "yes",
      type: "confirm",
      message: "Bump?",
      initial: true
    }).then((r) => r.yes)) {
      process5.exit(1);
    }
  }
  await runNpmScript("preversion" /* PreVersion */, operation);
  await updateFiles(operation);
  if (operation.options.execute) {
    if (typeof operation.options.execute === "function") {
      await operation.options.execute(operation);
    } else {
      const [command, ...args] = (0, import_parse.default)(operation.options.execute);
      console.log(symbols_exports.info, "Executing script", command, ...args);
      await x4(command, args, {
        nodeOptions: {
          stdio: "inherit",
          cwd: operation.options.cwd
        }
      });
      console.log(symbols_exports.success, "Script finished");
    }
  }
  await runNpmScript("version" /* Version */, operation);
  await gitCommit(operation);
  await gitTag(operation);
  await runNpmScript("postversion" /* PostVersion */, operation);
  await gitPush(operation);
  return operation.results;
}
function printSummary(operation) {
  console.log();
  console.log(`   files ${operation.options.files.map((i) => import_picocolors3.default.bold(i)).join("\n         ")}`);
  if (operation.options.commit)
    console.log(`  commit ${import_picocolors3.default.bold(formatVersionString(operation.options.commit.message, operation.state.newVersion))}`);
  if (operation.options.tag)
    console.log(`     tag ${import_picocolors3.default.bold(formatVersionString(operation.options.tag.name, operation.state.newVersion))}`);
  if (operation.options.execute)
    console.log(` execute ${import_picocolors3.default.bold(typeof operation.options.execute === "function" ? "function" : operation.options.execute)}`);
  if (operation.options.push)
    console.log(`    push ${import_picocolors3.default.cyan(import_picocolors3.default.bold("yes"))}`);
  console.log();
  console.log(`    from ${import_picocolors3.default.bold(operation.state.currentVersion)}`);
  console.log(`      to ${import_picocolors3.default.green(import_picocolors3.default.bold(operation.state.newVersion))}`);
  console.log();
}
async function versionBumpInfo(arg = {}) {
  if (typeof arg === "string")
    arg = { release: arg };
  const operation = await Operation.start(arg);
  await getCurrentVersion(operation);
  await getNewVersion(operation);
  return operation;
}

// src/config.ts
import { dirname } from "node:path";
import process6 from "node:process";
import { loadConfig } from "c12";
import escalade from "escalade/sync";
var bumpConfigDefaults = {
  commit: true,
  push: true,
  tag: true,
  sign: false,
  recursive: false,
  noVerify: false,
  confirm: true,
  ignoreScripts: false,
  all: false,
  noGitCheck: true,
  files: []
};
async function loadBumpConfig(overrides, cwd = process6.cwd()) {
  const name = "bump";
  const configFile = findConfigFile(name, cwd);
  const { config } = await loadConfig({
    name,
    defaults: bumpConfigDefaults,
    overrides: __spreadValues({}, overrides),
    cwd: configFile ? dirname(configFile) : cwd
  });
  return config;
}
function findConfigFile(name, cwd) {
  let foundRepositoryRoot = false;
  try {
    const candidates = ["js", "mjs", "ts", "mts", "json"].map((ext) => `${name}.config.${ext}`);
    return escalade(cwd, (_dir, files) => {
      const match = files.find((file) => {
        if (candidates.includes(file))
          return true;
        if (file === ".git")
          foundRepositoryRoot = true;
        return false;
      });
      if (match)
        return match;
      if (foundRepositoryRoot) {
        throw null;
      }
      return false;
    });
  } catch (error2) {
    if (foundRepositoryRoot)
      return null;
    throw error2;
  }
}
function defineConfig(config) {
  return config;
}

export {
  __spreadValues,
  __spreadProps,
  __objRest,
  __toESM,
  symbols_exports,
  require_picocolors,
  isReleaseType,
  ProgressEvent,
  NpmScript,
  versionBump,
  versionBumpInfo,
  bumpConfigDefaults,
  loadBumpConfig,
  defineConfig
};
